# Devils Offline Project Summary
**Date:** November 16, 2025

## Project Architecture Overview
Modern Angular offline-first production tracking application using SignalStore, IDB persistence, and optimistic UI updates with eventual server consistency.

---

## Core Entity Components

| Entity | Grid Columns | Form Fields | Store Type | IDB Table | Primary Key |
|--------|-------------|-------------|------------|-----------|-------------|
| **Blocks** | Block, Division, Description, BlockVolume | Block, Division, Description, BlockVolume | SignalStore | blocks | BlockId |
| **Productions** | ProductionId, BlockId, UserId, Date | 38 fields (Harvesting: 10, RoadConstruction: 14, Graveling: 14) | SignalStore | productions | ProductionId |
| **Rates** | RateId, Type, SubType, Rate | Type, SubType, Rate | SignalStore | rates | RateId |
| **Products** | ProductName, Category, UnitPrice, UnitsInStock | ProductName, Category, Supplier, etc. | SignalStore | products | ProductId |
| **Reports** | N/A (computed aggregates) | N/A (read-only display) | Computed from Productions + Blocks + Rates | N/A | N/A |

---

## Standard Component Pattern

### Grid Component (`*.grid.ts`)
```typescript
// Pattern: Kendo Grid with toolbar, 4 data columns, command column
- [kendoGridBinding]="store['entities']()"
- Grid state: skip, pageSize, sort, group, filter
- Pagination: [pageable]="true"
- Features: sortable, groupable, reorderable, filterable, resizable
- Toolbar: Plus icon button → createX()
- Commands: Edit (pencil), Remove (trash)
- Column count: 4 data columns + 1 command column
```

### Form Component (`*.form.ts`)
```typescript
// Pattern: Reactive Forms with manual validation
- FormGroup with FormControl<T> for each field
- NO validators in FormControl definitions
- NO [disabled]="!form.valid" on buttons
- Manual validation in save() method
- Title: <h2>{{ isCreateMode ? 'Create X' : 'Update X' }}</h2>
- Kendo outline style: fillMode="outline"
- Two-column layout: .outline-div class
- Button group: Save (primary), Cancel
```

### Store (`*.state.ts`)
```typescript
// Pattern: SignalStore with entities, grid state, IDB persistence
export const XStore = signalStore(
  withState({ /* initial state */ }),
  withEntities<X>(),
  withCallState(),
  withGridState(),
  withStorageSync({ key: 'x', source: 'idb', storeName: 'x' }),
  withOfflineSync<X>({ entityName: 'x', apiUrl: '/api/x' }),
  withMethods((store) => ({
    // CRUD operations
  }))
);
```

---

## IDB Persistence Layer

| Function | Purpose | Returns | Error Handling |
|----------|---------|---------|----------------|
| `getState(key)` | Load state from IDB | `Promise<T \| null>` | Returns null on error |
| `persistState(key, state)` | Save state to IDB | `Promise<void>` | Try-catch, console.warn |
| `persist(entityId, entity)` | Save single entity | `Promise<void>` | Try-catch wrapper |
| `persistMany(entities)` | Bulk save entities | `Promise<void>` | Try-catch wrapper |
| `remove(entityId)` | Delete single entity | `Promise<void>` | Try-catch wrapper |
| `removeAll()` | Clear all entities | `Promise<void>` | Try-catch wrapper |
| `getAll()` | Load all entities | `Promise<T[]>` | Returns empty array on error |

---

## Offline Sync - Failed Request Queue

| Method | Request Type | When Called | Payload Structure |
|--------|-------------|-------------|-------------------|
| `addToQueue(POST)` | POST | On create | `{ entityId, method: 'POST', body: newEntity }` |
| `addToQueue(PUT)` | PUT | On update | `{ entityId, method: 'PUT', body: dirtyFields }` |
| `addToQueue(DELETE)` | DELETE | On remove | `{ entityId, method: 'DELETE', body: null }` |

### Failed Request IDB Table
```typescript
interface FailedRequest {
  id: string;              // Auto-increment ID
  entityId: string;        // Entity primary key
  timestamp: number;       // Date.now()
  method: 'POST' | 'PUT' | 'DELETE';
  body: T | Partial<T> | null;
  entityName: string;      // 'blocks', 'productions', etc.
}
```

---

## Triple Timestamp Pattern
```typescript
// Indempotency keys for eventual consistency
branch: DateTimeOffsetString;   // Local edit timestamp
submit: DateTimeOffsetString;   // Optimistic UI commit
commit: DateTimeOffsetString;   // Server acknowledgment
```

---

## Component File Structure

```
apps/demo/src/app/
├── blocks/
│   ├── blocks.grid.ts          (4 columns: Block, Division, Description, BlockVolume)
│   ├── blocks.form.ts          (4 fields, manual validation)
│   ├── blocks.model.ts         (Block interface)
│   ├── blocks.state.ts         (BlocksStore with IDB + offline sync)
│   └── blocks.routes.ts
├── productions/
│   ├── productions.grid.ts     (4 columns: ProductionId, BlockId, UserId, Date)
│   ├── productions.form.ts     (38 fields, 3 tabs, virtual keyboards)
│   ├── productions.model.ts    (Flattened Production interface)
│   ├── productions.state.ts    (ProductionsStore)
│   └── productions.routes.ts
├── rates/
│   ├── rates.grid.ts           (4 columns: RateId, Type, SubType, Rate)
│   ├── rates.form.ts           (3 fields, manual validation)
│   ├── rates.model.ts          (Rate interface)
│   ├── rates.state.ts          (RatesStore)
│   └── rates.routes.ts
├── products/
│   ├── products.grid.ts        (4 columns: ProductName, Category, UnitPrice, UnitsInStock)
│   ├── products.form.ts        (Manual validation)
│   ├── products.model.ts       (Product interface)
│   ├── products.state.ts       (ProductsStore)
│   └── products.routes.ts
└── reports/
    ├── reports.ts              (Computed aggregates from stores)
    ├── report.component.ts     (Display component)
    ├── report.component.html   (Table with variance color coding)
    └── report.model.ts         (Report interfaces)
```

---

## Key Libraries & Versions

| Library | Version | Purpose |
|---------|---------|---------|
| Angular | 21.0.0-rc.1 | Framework |
| Kendo UI | 20.1.1 | Grid, forms, layout |
| @ngrx/signals | Latest | SignalStore pattern |
| IndexedDB | Native | Offline persistence |
| RxJS | Latest | Reactive programming (minimal use) |

---

## Global Styles

```css
.outline-form { 
  display: grid; 
  gap: 15px; 
}

.outline-div { 
  display: grid; 
  grid-template-columns: repeat(2, 1fr); 
  gap: 15px; 
}

.button-group { 
  display: flex; 
  gap: 10px; 
  margin-top: 20px; 
}
```

---

## Report Calculations

### Pricing Map
```typescript
// Computed from RatesStore - maps equipment Type to Rate value
pricing = computed(() => {
  const rates = this.ratesStore.entities();
  return rates.reduce((acc, rate) => {
    acc[rate.Type] = rate.Rate;  
    // Result: { 'D7': 277.23, '320': 180.32, 'RockTruck': 227.16, ... }
    return acc;
  }, {} as Record<string, number>);
});
```

### Cost Calculation Example
```typescript
// Production has: RCat1Type='D7', RCat1=5 hours
// Lookup: pricing['D7'] = 277.23
// Cost: 277.23 * 5 = 1,386.15
AccumulatedCost += (pricing[production.RCat1Type] || 0) * production.RCat1;
```

### Variance Color Coding
```typescript
// Harvesting (hours) - green = under budget (good)
getVarianceHighlightColor(variance: number): string {
  return Math.abs(variance) > 0 ? (variance > 0 ? 'green' : 'red') : 'black';
}

// Cost (Road/Gravel) - red = over budget (bad)
getVarianceLowlightColor(variance: number): string {
  return Math.abs(variance) > 0 ? (variance > 0 ? 'red' : 'green') : 'black';
}
```

Applied in template:
```html
<!-- Harvesting variance - green when ahead of schedule -->
<td [style.color]="getVarianceHighlightColor(harvest.HVar)">
  {{ harvest.HVar | number:'1.2-2' }}
</td>

<!-- Road Construction variance - red when over budget -->
<td [style.color]="getVarianceLowlightColor(block.RoadConstruction.Var)">
  {{ block.RoadConstruction.Var | currency }}
</td>
```

---

## Virtual Keyboard System

### Equipment Type Keyboards
```typescript
// Cat keyboard - Caterpillar dozer types
openCatKeyboard(field: string, title: string): void {
  this.keyboardForm.openEquipment(field, title, ['D6', 'D7', 'D8', '527']);
}

// Hoe keyboard - Excavator types
openHoeKeyboard(field: string, title: string): void {
  this.keyboardForm.openEquipment(field, title, ['250', '290', '320', '350']);
}

// Numeric keyboard - Hours, percentages, quantities
openNumericKeyboard(field: string, title: string): void {
  this.keyboardForm.openNumeric(field, title, true);
}
```

### Usage in Template
```html
<kendo-textbox 
  formControlName="RCat1Type" 
  [readonly]="true" 
  (click)="openCatKeyboard('RCat1Type', 'Cat 1 Type')">
</kendo-textbox>
```

**Design Philosophy:**
- Large buttons for "big trucker thumbs"
- Center screen popup (not dropdown)
- No zeros in blank numeric fields
- Equipment keyboards show Type codes that map to rates

---

## Devil's Offline Philosophy

> *"The greatest trick the Devil ever pulled was convincing the world he didn't exist."*
> 
> **Our twist:** "Our greatest trick is convincing the app the server does not exist."

### Core Principles

1. **Never wait for server** - All operations complete instantly in UI
2. **Autoincrement IDs** - Client generates GUIDs, never blocks on server IDs
3. **Optimistic UI** - Update UI first, sync to server in background
4. **Triple timestamp** - Branch/submit/commit for idempotency
5. **Grid/Store agnostic** - Components don't know internet exists
6. **IDB first** - Server is just a slow secondary data source
7. **Eventual consistency** - Failed requests queued and retried

### Implementation Details

**No Blocking Operations:**
```typescript
// ❌ NEVER do this
const id = await http.post('/api/productions', data).toPromise();
this.store.add({ ...data, id });  // UI waits for server!

// ✅ ALWAYS do this
const id = generateGuid();
this.store.add({ ...data, id });  // UI updates immediately!
// Background sync happens automatically via withOfflineSync
```

**Failed Request Recovery:**
- All POST/PUT/DELETE operations captured
- Stored in IDB 'failedRequests' table
- Retried automatically on reconnection
- No user intervention required
- UI never blocks or shows loading spinners

**Data Flow:**
```
User Action → Form Submit
    ↓
Generate GUID
    ↓
Update SignalStore (instant UI update)
    ↓
Persist to IDB (local backup)
    ↓
Background HTTP request
    ├─ Success → Remove from failed queue
    └─ Failure → Add to failed queue for retry
```

---

## Production Data Model

### Flattened Structure (NOT Nested)
```typescript
interface Production {
  // Metadata
  ProductionId: string;
  BlockId: string;
  UserId: string;
  Date: DateTimeOffsetString;
  TimeStamp: DateTimeOffsetString;
  
  // Harvesting (H prefix)
  HBunchingH: number;    // Hours
  HBunchingP: number;    // Percent
  HSkiddingH: number;
  HSkiddingP: number;
  // ... 5 activities × 2 fields = 10 fields
  
  // Road Construction (R prefix)
  RCat1Type: string;     // Equipment type code (D7, 527, etc)
  RCat1: number;         // Hours used
  RCat2Type: string;
  RCat2: number;
  RHoe1Type: string;     // Excavator type (250, 320, etc)
  RHoe1: number;
  RHoe2Type: string;
  RHoe2: number;
  RRockTruck: number;    // Fixed equipment
  RGrader: number;
  RPacker: number;
  RLabour: number;
  RPercent: number;      // Completion percentage
  // 14 fields total
  
  // Graveling (G prefix)
  GCat1Type: string;
  GCat1: number;
  // ... mirrors Road Construction
  GPercent: number;
  // 14 fields total
}
```

**Why Flattened?**
- Direct form binding (no nested FormGroups)
- Simple IDB storage
- Easy grid display
- No object traversal in calculations
- Form matches model 1:1

---

## Common Patterns & Anti-Patterns

### ✅ DO

```typescript
// Manual validation
async save(): Promise<void> {
  const formValue = this.form.getRawValue();
  if (!formValue.blockId || !formValue.division) {
    console.warn('Required fields missing');
    return;
  }
  // ... proceed with save
}

// Direct field access
const cost = production.RCat1 * pricing[production.RCat1Type];

// Immediate UI update
const newId = generateGuid();
await this.store.setEntities([...this.store.entities(), newEntity]);
```

### ❌ DON'T

```typescript
// NO validators in FormControl
BlockId: new FormControl('', { validators: Validators.required })  // ❌

// NO disabled buttons
<button [disabled]="!form.valid">Save</button>  // ❌

// NO nested object access
const hours = production.Harvesting.HBunchingH;  // ❌ (data is flat)

// NO UBlockId field
production.UBlockId === block.UBlockId  // ❌ (field doesn't exist)

// NO waiting for server
const response = await http.post(...);  // ❌
this.form.patchValue(response);
```

---

## Grid Standardization

All entity grids follow the **4+1 column pattern**:

| Entity | Col 1 | Col 2 | Col 3 | Col 4 | Commands |
|--------|-------|-------|-------|-------|----------|
| Blocks | Block | Division | Description | BlockVolume | Edit/Remove |
| Productions | ProductionId | BlockId | UserId | Date | Edit/Remove |
| Rates | RateId | Type | SubType | Rate | Edit/Remove |
| Products | ProductName | Category | UnitPrice | UnitsInStock | Edit/Remove |

**Rationale:**
- Consistent user experience
- Mobile-friendly width
- Essential info only
- Edit form shows full details

---

## Recent Session Fixes

### Issues Resolved (Nov 16, 2025)

1. **Report showing all zeros**
   - Root cause: `pricing` signal was empty object `{}`
   - Fix: Computed from RatesStore, mapping `Type → Rate`
   - Impact: Road Construction and Graveling costs now calculate correctly

2. **Wrong pricing lookup**
   - Root cause: Used `SubType` instead of `Type` for pricing map
   - Fix: Changed to `pricing[production.RCat1Type]` using Type field
   - Impact: Equipment types (D7, 320, RockTruck) now resolve to correct rates

3. **Grid column inconsistency**
   - Root cause: Rates grid had 3 columns, others had 4
   - Fix: Added RateId column to rates grid
   - Impact: All grids now standardized to 4 data columns

4. **Form validation pattern**
   - Root cause: Validators and disabled buttons from old pattern
   - Fix: Removed validators, disabled buttons; added manual validation
   - Impact: Consistent form behavior across all entities

5. **Variance color coding**
   - Root cause: Old pipe-based approach removed
   - Fix: Added computed color helper functions passed to child component
   - Impact: Green/red variance indicators restored in reports

---

## Next Steps / Todo

- [ ] Convert productions form to Signal Forms (blocked by Kendo compatibility)
- [ ] Test offline sync retry mechanism
- [ ] Add user authentication/authorization
- [ ] Implement service worker for true offline capability
- [ ] Add data export/backup functionality
- [ ] Performance testing with large datasets
- [ ] Add unit tests for report calculations

---

## Key Learnings

### Data Structure
- **Flattened is better** for forms + IDB + grids
- Nested objects add complexity without benefit
- Direct field access simplifies calculations

### Offline-First
- **Optimistic UI is non-negotiable** for user experience
- Failed request queue provides resilience
- IDB persistence enables true offline work

### Form Pattern
- **Manual validation > automatic validators** for flexibility
- No disabled buttons = better UX feedback
- Two-column layout with outline style = modern clean look

### Component Architecture
- **Grid + Form + Store + Model** = complete entity system
- SignalStore replaces older NgRx patterns
- Computed signals replace selectors and pipes

---

*End of Summary - November 16, 2025*
